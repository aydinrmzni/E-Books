<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.07 [en] (Win98; I) [Netscape]">
   <META NAME="Author" CONTENT="Goran UnreaL Krajnovic">
   <TITLE>Chapter 11 - OpenGL Programming Guide (Addison-Wesley Publishing Company)</TITLE>
</HEAD>
<BODY BGCOLOR="#EFEFEF" LINK="#0000FF" VLINK="#551A8B" ALINK="#FF0000">

<DIV ALIGN=right><IMG SRC="figures/SGI_ID.gif" ALT="Silicon Graphics" NOSAVE HEIGHT=43 WIDTH=151 ALIGN=TEXTTOP></DIV>

<HR>
<H1>
Chapter 11<BR>
Evaluators and NURBS</H1>
<B>Chapter Objectives</B>
<P><B>Advanced</B>
<P>After reading this chapter, you'll be able to do the following:
<UL>Use OpenGL's evaluator commands to draw basic curves and surfaces
<BR>&nbsp;
<P>Use the GLU's higher-level NURBS facility to draw more complex curves
and surfaces</UL>
Note that this chapter presumes a number of prerequisites; they're listed
in "Prerequisites" .
<P>At the lowest level, graphics hardware draws points, line segments,
and polygons, which are usually triangles and quadrilaterals. Smooth curves
and surfaces are drawn by approximating them with large numbers of small
line segments or polygons. However, many useful curves and surfaces can
be described mathematically by a small number of parameters such as a few
<I>control points</I>. Saving the sixteen control points for a surface
requires much less storage than saving 1000 triangles together with the
normal vector information at each vertex. In addition, the 1000 triangles
only approximate the true surface, but the control points can accurately
describe the real surface.
<P>Evaluators provide a way to specify points on a curve or surface (or
part of one) using only the control points. The curve or surface can then
be rendered at any precision. In addition, normal vectors can be calculated
for surfaces automatically. You can use the points generated by an evaluator
in many ways - to draw dots where the surface would be, to draw a wireframe
version of the surface, or to draw a fully lighted and shaded version.
<P>You can use evaluators to describe any polynomial or rational polynomial
splines or surfaces of any degree. These include almost all splines and
spline surfaces in use today, including B-splines, NURBS (Non-Uniform Rational
B-Spline) surfaces, Bézier curves and surfaces, and Hermite splines. Since
evaluators provide only a low-level description of the points on a curve
or surface, however, they're typically used underneath utility libraries
that provide a higher-level interface to the programmer. The GLU's NURBS
facility is such a higher-level interface - the NURBS routines encapsulate
lots of complicated code, but the final rendering is done with evaluators.
<P>This chapter contains the following major sections:
<UL>"Prerequisites" discusses what knowledge is assumed for this chapter.
It also gives several references where you can obtain this information.
<BR>&nbsp;
<P>"Evaluators" explains how evaluators work and how to control them using
the appropriate OpenGL commands.
<BR>&nbsp;
<P>"The GLU NURBS Interface" describes the GLU routines for creating NURBS
surfaces.</UL>

<HR>
<H2>
<A NAME="X"></A>Prerequisites</H2>
Evaluators make splines and surfaces that are based on a Bézier (or Bernstein)
basis. The defining formulas for the functions in this basis are given
in this chapter, but the discussion doesn't include derivations or even
lists of all their interesting mathematical properties. If you want to
use evaluators to draw curves and surfaces using other bases, you must
know how to convert your basis to a Bézier basis. In addition, when you
render a Bézier surface or part of it using evaluators, you need to determine
the granularity of your subdivision. Your decision needs to take into account
the trade-off between high-quality (highly subdivided) images and high
speed. Determining an appropriate subdivision strategy can be quite complicated,
and it's not discussed here.
<P>Similarly, a complete discussion of NURBS is beyond the scope of this
book. The GLU NURBS interface is documented here, however, and programming
examples are provided for readers who already understand the subject. In
what follows, we assume that you know about NURBS control points, knot
sequences, and trimming curves.
<P>If you lack some of these prerequisites, the following references will
help.
<UL>Burns, Derrick. <I>Dynamic Trimmed Surface Rendering</I>. Ph.D. dissertation,
Stanford University, 1993.
<BR>&nbsp;
<P>de Boor, Carl. <I>A Practical Guide to Splines</I>. New York: Springer-Verlag,
1985.
<BR>&nbsp;
<P>Farin, Gerald. <I>Curves and Surfaces for Computer-Aided Geometric Design</I>.
San Diego, Calif: Academic Press, 1990.
<BR>&nbsp;
<P>Mortenson, Michael. <I>Geometric Modeling</I>. New York: John Wiley
&amp; Sons, 1985.
<BR>&nbsp;
<P>Newman, William and Sproull, Robert. <I>Principles of Interactive Computer
Graphics</I>. New York: McGraw-Hill, 1979.</UL>
Some of the terms used in this chapter might have slightly different meanings
in other books on spline curves and surfaces, since there isn't total agreement
among the practitioners of this art. Generally, the OpenGL meanings are
a bit more restrictive. For example, OpenGL evaluators always use Bézier
bases; in other contexts, evaluators might refer to the same concept, but
with an arbitrary basis.
<P>
<HR>
<H2>
Evaluators</H2>
A Bézier curve is a vector-valued function of one variable
<P><B>C</B>(<I>u</I>) = [<B>X</B>(<I>u</I>) <B>Y</B>(<I>u</I>) <B>Z</B>(<I>u</I>)]
<P>where <I>u</I> varies in some domain (say [0,1]). A Bézier surface patch
is a vector-valued function of two variables
<P><B>S</B>(<I>u,v</I>) = [<B>X</B>(<I>u,v</I>) <B>Y</B>(<I>u,v</I>) <B>Z</B>(<I>u,v</I>)]
<P>where <I>u</I> and <I>v</I> can both vary in some domain. The range
isn't necessarily three-dimensional as shown here. You might want two-dimensional
output for curves on a plane or texture coordinates, or you might want
four-dimensional output to specify RGBA information. Even one-dimensional
output may make sense for gray levels, for example.
<P>For each <I>u</I> (or <I>u</I> and <I>v</I>, in the case of a surface),
the formula for <B>C()</B> (or <B>S()</B>) calculates a point on the curve
(or surface). To use an evaluator, first define the function <B>C()</B>
or <B>S()</B>, enable it, and then use the <B>glEvalCoord1()</B> or <B>glEvalCoord2()</B>
command instead of <B>glVertex()</B>. This way, the curve or surface vertices
can be used like any other vertices - to form points or lines, for example.
In addition, other commands automatically generate series of vertices that
produce a regular mesh uniformly spaced in <I>u</I> (or in <I>u</I> and
<I>v</I>). One- and two-dimensional evaluators are similar, but the description
is somewhat simpler in one dimension, so that case is discussed first.
<P>
<HR>
<H3>
One-Dimensional Evaluators</H3>
This section presents an example of using one-dimensional evaluators to
draw a curve. It then describes the commands and equations that control
evaluators.
<H4>
One-Dimensional Example: A Simple Bézier Curve</H4>
The program shown in Example 11-1 draws a cubic Bézier curve using four
control points, as shown in Figure 11-1 .
<P><IMG SRC="figures/bezcurve.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-1 : </B>A Bézier Curve
<BR>&nbsp;
<BR>&nbsp;
<P><B>Example 11-1 : </B>Drawing a Bézier Curve Using Four Control Points:
bezcurve.c
<PRE>#include &lt;GL/gl.h>
#include &lt;GL/glu.h>
#include "aux.h"

GLfloat ctrlpoints[4][3] = {
&nbsp;&nbsp;&nbsp; { -4.0, -4.0, 0.0}, { -2.0, 4.0, 0.0},&nbsp;
&nbsp;&nbsp;&nbsp; {2.0, -4.0, 0.0}, {4.0, 4.0, 0.0}};

void myinit(void)
{
&nbsp;&nbsp;&nbsp; glClearColor(0.0, 0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 4,&amp;ctrlpoints[0][0]);
&nbsp;&nbsp;&nbsp; glEnable(GL_MAP1_VERTEX_3);
&nbsp;&nbsp;&nbsp; glShadeModel(GL_FLAT);
}

void display(void)
{
&nbsp;&nbsp;&nbsp; int i;

&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&nbsp;&nbsp;&nbsp; glColor3f(1.0, 1.0, 1.0);
&nbsp;&nbsp;&nbsp; glBegin(GL_LINE_STRIP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt;= 30; i++)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord1f((GLfloat) i/30.0);
&nbsp;&nbsp;&nbsp; glEnd();
&nbsp;&nbsp; /* The following code displays the control points as dots. */
&nbsp;&nbsp;&nbsp; glPointSize(5.0);
&nbsp;&nbsp;&nbsp; glColor3f(1.0, 1.0, 0.0);
&nbsp;&nbsp;&nbsp; glBegin(GL_POINTS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 4; i++)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;ctrlpoints[i][0]);
&nbsp;&nbsp;&nbsp; glEnd();
&nbsp;&nbsp;&nbsp; glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
&nbsp;&nbsp;&nbsp; glViewport(0, 0, w, h);
&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
&nbsp;&nbsp;&nbsp; if (w &lt;= h)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-5.0*(GLfloat)w/(GLfloat)h,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
}


int main(int argc, char** argv)
{
&nbsp;&nbsp;&nbsp; auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
&nbsp;&nbsp;&nbsp; auxInitPosition (0, 0, 500, 500);
&nbsp;&nbsp;&nbsp; auxInitWindow (argv[0]);
&nbsp;&nbsp;&nbsp; myinit();
&nbsp;&nbsp;&nbsp; auxReshapeFunc (myReshape);
&nbsp;&nbsp;&nbsp; auxMainLoop(display);
}</PRE>
A cubic Bézier curve is described by four control points, which appear
in this example in the <B>ctrlpoints[][]</B> array. This array is one of
the arguments to <B>glMap1f()</B>. All the arguments for this command are
as follows:
<DL>
<DT>
GL_MAP1_VERTEX_3</DT>

<DD>
</DD>

<BR>Three-dimensional vertices are produced
<DT>
</DT>

<BR>0
<DD>
</DD>

<BR>Low value of parameter <B>u</B>
<DT>
</DT>

<BR>1
<DD>
</DD>

<BR>High value of parameter <B>u</B>
<DT>
</DT>

<BR>3
<DD>
</DD>

<BR>The number of floating-point values to advance in the data between
one control point and the next
<DT>
</DT>

<BR>4
<DD>
</DD>

<BR>The order of the spline, which is the degree+1; in this case, the degree
is 3 (since the curve is a cubic)
<DT>
</DT>

<BR>&amp;ctrlpoints[0][0]
<DD>
</DD>

<BR>Pointer to the first control point's data</DL>
Note that the second and third arguments control the parameterization of
the curve - as the variable <I>u</I> ranges from 0 to 1, the curve goes
from one end to the other. The call to <B>glEnable()</B> enables the one-dimensional
evaluator for two-dimensional vertices.
<P>The curve is drawn in the routine <B>display() </B>between the <B>glBegin()
</B>and <B>glEnd()</B> calls. Since the evaluator is enabled, the command
<B>glEvalCoord1f()</B> is just like issuing a <B>glVertex()</B> command
with coordinates that are the coordinates of a vertex on the curve corresponding
to the input parameter <I>u</I>.
<H4>
Defining and Evaluating a One-Dimensional Evaluator</H4>
The Bernstein polynomial of degree <B>n</B> (or order <B>n</B>+1) is given
by
<P><IMG SRC="figures/eq1101.gif" ALT="[IMAGE]" NOSAVE >
<P>If Pi represents a set of control points (one-, two-, three-, or even
four- dimensional), then the equation
<P><IMG SRC="figures/eq1102.gif" ALT="[IMAGE]" NOSAVE >
<P>represents a Bézier curve as <I>u</I> varies from 0 to 1. To represent
the same curve but allowing <I>u</I> to vary between <I>u</I>1 and <I>u</I>2
instead of 0 and 1, evaluate
<P><IMG SRC="figures/eq1103.gif" ALT="[IMAGE]" NOSAVE >
<P>The command <B>glMap1()</B> defines a one-dimensional evaluator that
uses these equations.void <B>glMap1</B>{fd}(GLenum <B>target</B>, <B>TYPEu1</B>,
<B>TYPE</B><I>u2</I>, GLint <B>stride</B>, GLint <B>order</B>, <B>const
TYPE*points</B>);
<P>Defines a one-dimensional evaluator. The <B>target</B> parameter specifies
what the control points represent, as shown in Table 11-1 , and therefore
how many values need to be supplied in <B>points</B>. The points can represent
vertices, RGBA color data, normal vectors, or texture coordinates. Forexample,
with GL_MAP1_COLOR_4, the evaluator generates color data along a curve
in four-dimensional (RGBA) color space. You also use the parameter values
listed in Table 11-1 to enable each defined evaluator before you invoke
it. Pass the appropriate value to <B>glEnable()</B> or <B>glDisable()</B>
to enable or disable the evaluator.
<P>The second two parameters for <B>glMap1*()</B>, <I>u1</I> and <I>u2</I>,
indicate the range for the variable <I>u</I>. The variable <B>stride</B>
is the number of single- or double-precision values (as appropriate) in
each block of storage. Thus, it's an offset value between the beginning
of one control point and the beginning of the next.
<P>The <B>order</B> is the degree plus one, and it should agree with the
number of control points. The <B>points</B> parameter points to the first
coordinate of the first control point. Using the example data structure
for <B>glMap1*()</B>, use the following for <B>points</B>:
<P>(GLfloat *)(&amp;ctlpoints[0].x)
<TABLE BORDER CELLPADDING=10 >
<CAPTION ALIGN=TOP><B>Table 11-1 : </B>Types of Control Points for Use
with glMap1*()</CAPTION>

<TR ALIGN=LEFT VALIGN=TOP>
<TH>Parameter</TH>

<TH>Meaning</TH>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_VERTEX_3</TD>

<TD><I>x, y, z</I> vertex coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_VERTEX_4</TD>

<TD><I>x, y, z, w </I>vertex coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_INDEX</TD>

<TD>color index</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_COLOR_4</TD>

<TD>R, G, B, A</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_NORMAL</TD>

<TD>normal coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_TEXTURE_COORD_1</TD>

<TD><I>s</I> texture coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_TEXTURE_COORD_2</TD>

<TD><I>s, t</I> texture coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_TEXTURE_COORD_3</TD>

<TD><I>s, t, r</I> texture coordinates</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>GL_MAP1_TEXTURE_COORD_4</TD>

<TD><I>s, t, r, q</I> texture coordinates</TD>
</TR>
</TABLE>

<BR>&nbsp;
<P>More than one evaluator can be evaluated at a time. If you have both
a GL_MAP1_VERTEX_3 and a GL_MAP1_COLOR_4 evaluator defined and enabled,
for example, then calls to <B>glEvalCoord1()</B> generate both a position
and a color. Only one of the vertex evaluators can be enabled at a time,
although you might have defined both of them. Similarly, only one of the
texture evaluators can be active. Other than that, however, evaluators
can be used to generate any combination of vertex, normal, color, and texture-coordinate
data. If more than one evaluator of the same type is defined and enabled,
the one of highest dimension is used.
<P>Use<B> glEvalCoord1*()</B> to evaluate a defined and enabled one-dimensional
map.void <B>glEvalCoord1</B>{fd}{v}(<B>TYPE u</B>);
<P>Causes evaluation of the enabled one-dimensional maps. The argument
<B>u</B> is the value (or a pointer to the value, in the vector version
of the command) that's the domain coordinate.
<H4>
Defining Evenly Spaced Coordinate Values in One Dimension</H4>
You can use <B>glEvalCoord1()</B> with any values for <B>u</B>, but by
far the most common use is with evenly spaced values, as shown previously
in Example 11-1 . To obtain evenly spaced values, define a one-dimensional
grid using <B>glMapGrid1*()</B> and then apply it using <B>glEvalMesh1()</B>.void
<B>glMapGrid1</B>{fd}(GLint <B>n</B>, <B>TYPEu1</B>, <B>TYPEu2</B>);
<P>Defines a grid that goes from <B>u1</B> to <B>u2</B> in <B>n</B> steps,
which are evenly spaced.
<P>void <B>glEvalMesh1</B>(GLenum <B>mode</B>, GLint <B>p1</B>, GLint <B>p2</B>);
<P>Applies the currently defined map grid to all enabled evaluators. The
<B>mode</B> can be either GL_POINT or GL_LINE, depending on whether you
want to draw points or a connected line along the curve. The call has exactly
the same effect as issuing a <B>glEvalCoord1()</B> for each of the steps
between and including <B>p1</B> and <B>p2</B>, where 0 &lt;= <B>p1</B>,
<B>p2</B> &lt;= <B>n</B>. Programatically, it's equivalent to the following:
<PRE>glBegin(GL_POINTS);&nbsp;&nbsp;&nbsp; /* OR glBegin(GL_LINE_STRIP); */
for (i = p1; i &lt;= p2; i++)&nbsp;
&nbsp;&nbsp;&nbsp; glEvalCoord1(u1 + i*(u2-u1)/n);
glEnd();</PRE>
except that if <B>i</B> = 0 or <B>i</B> = <B>n</B>, then <B>glEvalCoord()</B>
is called with exactly <I>u1</I> or <I>u2</I> as its parameter.
<P>
<HR>
<H3>
Two-Dimensional Evaluators</H3>
In two dimensions, everything is similar to the one-dimensional case, except
that all the commands must take two parameters, <I>u</I> and <I>v</I>,
into account. Points, colors, normals, or texture coordinates must be supplied
over a surface instead of a curve. Mathematically, the definition of a
Bézier surface patch is given by
<P><IMG SRC="figures/eq1104.gif" ALT="[IMAGE]" NOSAVE >
<BR>&nbsp;
<BR>&nbsp;
<P>where <I>P</I>ij are a set of <I>m*n</I> control points, and the <I>B</I>i
are the same Bernstein polynomials for one dimension. As before, the <I>Pij</I>
can represent vertices, normals, colors, or texture coordinates.
<P>The procedure to use two-dimensional evaluators is similar to the procedure
for one dimension:
<OL>Define the evaluator(s) with <B>glMap2*()</B>.
<BR>&nbsp;
<P>Enable them by passing the appropriate value to <B>glEnable()</B>.
<BR>&nbsp;
<P>Invoke them either by calling <B>glEvalCoord2()</B> between a <B>glBegin()</B>
and <B>glEnd()</B> pair, or by specifying and then applying a mesh with
<B>glMapGrid2()</B> and <B>glEvalMesh2()</B>.</OL>

<H4>
Defining and Evaluating a Two-Dimensional Evaluator</H4>
Use <B>glMap2*()</B> and <B>glEvalCoord2*()</B> to define and then invoke
a two-dimensional evaluator.void <B>glMap2</B>{fd}(GLenum <B>target</B>,
<B>TYPEu1</B>, <B>TYPEu2</B>, GLint <B>ustride</B>, GLint <B>uorder</B>,
<B>TYPEv1</B>, <B>TYPEv2</B>, GLint <B>vstride</B>, GLint <B>vorder</B>,
<B>TYPE points</B>);
<P>The <B>target</B> parameter can have any of the values in Table 11-1
, except that the string MAP1 is replaced with MAP2. As before, these values
are also used with <B>glEnable()</B> to enable the corresponding evaluator.
Minimum and maximum values for both <I>u </I>and <I>v</I> are provided
as <B>u1</B>, <B>u2</B>, <B>v1</B>, and <B>v2</B>. The parameters <B>ustride</B>
and <B>vstride</B> indicate the number of single- or double-precision values
(as appropriate) between independent settings for these values allows users
to select a subrectangle of control points out of a much larger array.
For example, if the data appears in the form
<PRE>GLfloat ctlpoints[100][100][3];</PRE>
and you want to use the 4x4 subset beginning at ctlpoints[20][30], choose
<B>ustride</B> to be 100*3, and <B>vstride</B> to be 3. The starting point,
<B>points</B>, should be set to &amp;ctlpoints[20][30][0]. Finally, the
order parameters, <B>uorder</B> and <B>vorder</B>, can be different, allowing
patches that are cubic in one direction and quadratic in the other, for
example.
<P>void <B>glEvalCoord2</B>{fd}{v}(<B>TYPE u, TYPE v</B>);
<P>Causes evaluation of the enabled two-dimensional maps. The arguments
<B>u </B>and<B> v</B> are the values (or a pointer to the value, in the
vector version of the command) for the domain coordinates. If either of
the vertex evaluators is enabled (GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4),
then the normal to the surface is computed analytically. This normal is
associated with the generated vertex if automatic normal generation has
been enabled by passing GL_AUTO_NORMAL to <B>glEnable()</B>. If it's disabled,
the corresponding enabled normal map is used to produce a normal. If no
such map exists, the current normal is used.
<H4>
Two-Dimensional Example: A Bézier Surface</H4>
Example 11-2 draws a wireframe Bézier surface using evaluators, as shown
in Figure 11-2 . In this example, the surface is drawn with nine curved
lines in each direction. Each curve is drawn as 30 segments. To get the
whole program, add the <B>myReshape()</B> and <B>main()</B> routines from
Example 11-1 .
<P><IMG SRC="figures/bezsurf.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-2 : </B>A Bézier Surface
<BR>&nbsp;
<BR>&nbsp;
<P><B>Example 11-2 : </B>Drawing a Bézier Surface: bezsurf.c
<PRE>#include &lt;GL/gl.h>
#include &lt;GL/glu.h>
#include "aux.h"

GLfloat ctrlpoints[4][4][3] = {
&nbsp;&nbsp;&nbsp; {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

void display(void)
{
&nbsp;&nbsp;&nbsp; int i, j;

&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&nbsp;&nbsp;&nbsp; glColor3f(1.0, 1.0, 1.0);
&nbsp;&nbsp;&nbsp; glPushMatrix ();
&nbsp;&nbsp;&nbsp; glRotatef(85.0, 1.0, 1.0, 1.0);
&nbsp;&nbsp;&nbsp; for (j = 0; j &lt;= 8; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINE_STRIP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt;= 30; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2f((GLfloat)i/30.0, (GLfloat)j/8.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINE_STRIP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt;= 30; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2f((GLfloat)j/8.0, (GLfloat)i/30.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; glPopMatrix ();
&nbsp;&nbsp;&nbsp; glFlush();
}

void myinit(void)
{
&nbsp;&nbsp;&nbsp; glClearColor (0.0, 0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
&nbsp;&nbsp;&nbsp; glEnable(GL_MAP2_VERTEX_3);
&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp; glShadeModel(GL_FLAT);
}</PRE>

<H4>
Defining Evenly Spaced Coordinate Values in Two Dimensions</H4>
In two dimensions, the <B>glMapGrid2*()</B> and <B>glEvalMesh2()</B> commands
are similar to the one-dimensional versions, except that both <I>u</I>
and <I>v</I> information must be included.void <B>glMapGrid2</B>{fd}(GLint
<B>nu</B>, <B>TYPEu1</B>, <B>TYPEu2</B>, GLint <B>nv</B>, <B>TYPEv1</B>,
<B>TYPEv2</B>);
<BR>void <B>glEvalMesh2</B>(GLenum <B>mode</B>, GLint <B>p1</B>, GLint
<B>p2</B>, GLint <B>q2</B>, GLint <B>q2</B>);
<P>Defines a two-dimensional map grid that goes from <B>u1</B> to <B>u2</B>
in <B>nu</B> evenly spaced steps and from <B>v1</B> to <B>v2</B> in <B>nv</B>
steps (<B>glMapGrid2*()</B>), and then applies this grid to all enabled
evaluators (<B>glEvalMesh2()</B>). The only significant difference from
the one-dimensional versions of these two commands is that in <B>glEvalMesh2()</B>,
the <B>mode</B> parameter can be GL_FILL as well as GL_POINT or GL_LINE.
GL_FILL generates filled polygons using the quad-mesh primitive. Stated
precisely, <B>glEvalMesh2()</B> is nearly equivalent to one of the following
three code fragments. (It's nearly equivalent because when<B> i</B> is
equal to <B>nu</B> or <B>j</B> to <B>nv</B>, the parameter is exactly equal
to <B>u2</B> or <B>v2</B>, not to <B>u1</B><I>+</I><B>nu</B><I>*(</I><B>u2</B>-<B>u1</B><I>)/</I><B>nu</B>,
which might be slightly different due to round-off error.)
<PRE>glBegin(GL_POINTS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mode == GL_POINT */&nbsp;
for (i = nu1; i &lt;= nu2; i++)&nbsp;
&nbsp;&nbsp;&nbsp; for (j = nv1; j &lt;= nv2; j++)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);
glEnd();</PRE>
or
<PRE>for (i = nu1; i &lt;= nu2; i++) {&nbsp;&nbsp;&nbsp;&nbsp; /* mode == GL_LINE */
&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = nv1; j &lt;= nv2; j++)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);&nbsp;
&nbsp;&nbsp;&nbsp; glEnd();&nbsp;
}&nbsp;
for (j = nv1; j &lt;= nv2; j++) {&nbsp;
&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);&nbsp;
&nbsp;&nbsp;&nbsp; for (i = nu1; i &lt;= nu2; i++)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);&nbsp;
&nbsp;&nbsp;&nbsp; glEnd();&nbsp;
}</PRE>
or
<PRE>for (i = nu1; i &lt; nu2; i++) {&nbsp;&nbsp;&nbsp;&nbsp; /* mode == GL_FILL */&nbsp;
&nbsp;&nbsp;&nbsp; glBegin(GL_QUAD_STRIP);
&nbsp;&nbsp;&nbsp; for (j = nv1; j &lt;= nv2; j++) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalCoord2(u1 + (i+1)*(u2-u1)/nu, v1+j*(v2-v1)/nv);
&nbsp;&nbsp;&nbsp; glEnd();&nbsp;
}</PRE>
Example 11-3 shows the differences necessary to draw the same Bézier surface
as Example 11-2 , but using <B>glMapGrid2()</B> and <B>glEvalMesh2()</B>
to subdivide the square domain into a uniform 8x8 grid. This program also
adds lighting and shading, as shown in Figure 11-3 .
<P><IMG SRC="figures/bezmesh.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-3 : </B>A Lit, Shaded Bézier Surface Drawn Using a Mesh
<BR>&nbsp;
<BR>&nbsp;
<P><B>Example 11-3 : </B>Drawing a Lit, Shaded Bézier Surface Using a Mesh:
bezmesh.c
<PRE>void initlights(void)
{
&nbsp;&nbsp;&nbsp; GLfloat ambient[] = { 0.2, 0.2, 0.2, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat position[] = { 0.0, 0.0, 2.0, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_shininess[] = { 50.0 };

&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);

&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0, GL_POSITION, position);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS, mat_shininess);
}

void display(void)
{
&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&nbsp;&nbsp;&nbsp; glPushMatrix();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(85.0, 1.0, 1.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalMesh2(GL_FILL, 0, 8, 0, 8);
&nbsp;&nbsp;&nbsp; glPopMatrix();
&nbsp;&nbsp;&nbsp; glFlush();
}

void myinit(void)
{
&nbsp;&nbsp;&nbsp; glClearColor (0.0, 0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp; glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
&nbsp;&nbsp;&nbsp; glEnable(GL_MAP2_VERTEX_3);
&nbsp;&nbsp;&nbsp; glEnable(GL_AUTO_NORMAL);
&nbsp;&nbsp;&nbsp; glMapGrid2f(8, 0.0, 1.0, 8, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; initlights();
}</PRE>

<HR>
<H3>
Example: Using Evaluators for Textures</H3>
Example 11-4 enables two evaluators at the same time: The first generates
three-dimensional points on the same Bézier surface as Example 11-3 , and
the second generates texture coordinates. In this case, the texture coordinates
are the same as the <I>u</I> and <I>v</I> coordinates of the surface, but
a special flat Bézier patch must be created to do this.
<P>The flat patch is defined over a square with corners at (0, 0), (0,
1), (1, 0), and (1, 1); it generates (0, 0) at corner (0, 0), (0, 1) at
corner (0, 1), and so on. Since it's of order 2 (linear degree plus one),
evaluating this texture at the point (<I>u, v</I>) generates texture coordinates
(<I>s, t</I>). It's enabled at the same time as the vertex evaluator, so
both take effect when the surface is drawn. See Figure J-26 . If you want
the texture to repeat three times in each direction, change every 1.0 in
the array <B>texpts[][][]</B> to 3.0. Since the texture wraps in this example,
the surface is rendered with nine copies of the texture map.
<P><B>Example 11-4 : </B>Using Evaluators for Textures: texturesurf.c
<PRE>#include &lt;GL/gl.h>
#include &lt;GL/glu.h>
#include "aux.h"
#include &lt;math.h>

GLfloat ctrlpoints[4][4][3] = {
&nbsp;&nbsp;&nbsp; {{ -1.5, -1.5, 4.0}, { -0.5, -1.5, 2.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{ -1.5, -0.5, 1.0}, { -0.5, -0.5, 3.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{ -1.5, 0.5, 4.0}, { -0.5, 0.5, 0.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}},&nbsp;
&nbsp;&nbsp;&nbsp; {{ -1.5, 1.5, -2.0}, { -0.5, 1.5, -2.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{1.0, 0.0}, {1.0, 1.0}}};

void display(void)
{
&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&nbsp;&nbsp;&nbsp; glColor3f(1.0, 1.0, 1.0);
&nbsp;&nbsp;&nbsp; glEvalMesh2(GL_FILL, 0, 20, 0, 20);
&nbsp;&nbsp;&nbsp; glFlush();
}

#define&nbsp;&nbsp; imageWidth 64
#define&nbsp;&nbsp; imageHeight 64
GLubyte&nbsp;&nbsp; image[3*imageWidth*imageHeight];

void loadImage(void)
{
&nbsp;&nbsp;&nbsp; int i, j;
&nbsp;&nbsp;&nbsp; float ti, tj;

&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; imageWidth; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ti = 2.0*3.14159265*i/imageWidth;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; imageHeight; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tj = 2.0*3.14159265*j/imageHeight;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image[3*(imageHeight*i+j)] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GLubyte) 127*(1.0+sin(ti));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image[3*(imageHeight*i+j)+1] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GLubyte) 127*(1.0+cos(2*tj));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image[3*(imageHeight*i+j)+2] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GLubyte) 127*(1.0+cos(ti+tj));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

void myinit(void)
{
&nbsp;&nbsp;&nbsp; glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
&nbsp;&nbsp;&nbsp; glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 4, 2, &amp;texpts[0][0][0]);
&nbsp;&nbsp;&nbsp; glEnable(GL_MAP2_TEXTURE_COORD_2);
&nbsp;&nbsp;&nbsp; glEnable(GL_MAP2_VERTEX_3);
&nbsp;&nbsp;&nbsp; glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; loadImage();
&nbsp;&nbsp;&nbsp; glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
&nbsp;&nbsp;&nbsp; glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_REPEAT);
&nbsp;&nbsp;&nbsp; glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_REPEAT);
&nbsp;&nbsp;&nbsp; glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_NEAREST);
&nbsp;&nbsp;&nbsp; glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_NEAREST);
&nbsp;&nbsp;&nbsp; glTexImage2D(GL_TEXTURE_2D, 0, 3, imageWidth, imageHeight,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, GL_RGB, GL_UNSIGNED_BYTE, image);
&nbsp;&nbsp;&nbsp; glEnable(GL_TEXTURE_2D);
&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp; glEnable(GL_NORMALIZE);
&nbsp;&nbsp;&nbsp; glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
&nbsp;&nbsp;&nbsp; glViewport(0, 0, w, h);
&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
&nbsp;&nbsp;&nbsp; if (w &lt;= h)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-4.0*(GLfloat)w/(GLfloat)h,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);

&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
&nbsp;&nbsp;&nbsp; glRotatef(85.0, 1.0, 1.0, 1.0);
}


int main(int argc, char** argv)
{
&nbsp;&nbsp;&nbsp; auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
&nbsp;&nbsp;&nbsp; auxInitPosition (0, 0, 300, 300);
&nbsp;&nbsp;&nbsp; auxInitWindow (argv[0]);
&nbsp;&nbsp;&nbsp; myinit();
&nbsp;&nbsp;&nbsp; auxReshapeFunc (myReshape);
&nbsp;&nbsp;&nbsp; auxMainLoop(display);
}</PRE>

<HR>
<H2>
The GLU NURBS Interface</H2>
Although evaluators are the only OpenGL primitive available to directly
draw curves and surfaces, and even though they can be implemented very
efficiently in hardware, they're often accessed by applications through
higher-level libraries. The GLU provides a NURBS (Non-Uniform Rational
B-Spline) interface built on top of the OpenGL evaluator commands.
<P>
<HR>
<H3>
A Simple NURBS Example</H3>
If you understand NURBS, writing OpenGL code to manipulate NURBS curves
and surfaces is relatively easy, even with lighting and texture mapping.
Follow these steps to draw NURBS curves or untrimmed NURBS surfaces. (Trimmed
surfaces are discussed in "Trimming." )
<OL>If you intend to use lighting with a NURBS surface, call <B>glEnable()</B>
with GL_AUTO_NORMAL to automatically generate surface normals. (Or you
can calculate your own.)
<BR>&nbsp;
<P>Use <B>gluNewNurbsRenderer()</B> to create a pointer to a NURBS object,
which is referred to when creating your NURBS curve or surface.
<BR>&nbsp;
<P>If desired, call <B>gluNurbsProperty()</B> to choose rendering values,
such as the maximum size of lines or polygons that are used to render your
NURBS object.
<BR>&nbsp;
<P>Call <B>gluNurbsCallback()</B> if you want to be notified when an error
is encountered. (Error checking may slightly degrade performance.)
<BR>&nbsp;
<P>Start your curve or surface by calling <B>gluBeginCurve()</B> or <B>gluBeginSurface()</B>.
<BR>&nbsp;
<P>Generate and render your curve or surface. Call <B>gluNurbsCurve()</B>
or <B>gluNurbsSurface()</B> at least once with the control points (rational
or nonrational), knot sequence, and order of the polynomial basis function
for your NURBS object. You might call these functions additional times
to specify surface normals and/or texture coordinates.
<BR>&nbsp;
<P>Call <B>gluEndCurve()</B> or <B>gluEndSurface() </B>to complete the
curve or surface.</OL>
Example 11-5 renders a NURBS surface in the shape of a symmetrical hill
with control points ranging from -3.0 to 3.0. The basis function is a cubic
B-spline, but the knot sequence is nonuniform, with a multiplicity of 4
at each endpoint, causing the basis function to behave like a Bézier curve
in each direction. The surface is lighted, with a dark gray diffuse reflection
and white specular highlights. Figure 11-4 shows the surface as a wireframe
and lighted.
<P><IMG SRC="figures/surface.both.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-4 : </B>A NURBS Surface
<BR>&nbsp;
<BR>&nbsp;
<P><B>Example 11-5 : </B>Drawing a NURBS Surface: surface.c
<PRE>#include &lt;GL/gl.h>
#include &lt;GL/glu.h>
#include "aux.h"

GLfloat ctlpoints[4][4][3];
GLUnurbsObj *theNurb;

void init_surface(void)
{
&nbsp;&nbsp;&nbsp; int u, v;
&nbsp;&nbsp;&nbsp; for (u = 0; u &lt; 4; u++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (v = 0; v &lt; 4; v++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( (u == 1 || u == 2) &amp;&amp; (v == 1 || v == 2))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctlpoints[u][v][2] = 3.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctlpoints[u][v][2] = -3.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }&nbsp;
}

void myinit(void)
{
&nbsp;&nbsp;&nbsp; GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_shininess[] = { 100.0 };

&nbsp;&nbsp;&nbsp; glClearColor (0.0, 0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);
&nbsp;&nbsp;&nbsp; glDepthFunc(GL_LEQUAL);
&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp; glEnable(GL_AUTO_NORMAL);
&nbsp;&nbsp;&nbsp; glEnable(GL_NORMALIZE);
&nbsp;&nbsp;&nbsp; init_surface();

&nbsp;&nbsp;&nbsp; theNurb = gluNewNurbsRenderer();
&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 25.0);
&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
&nbsp;&nbsp;&nbsp; GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};

&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

&nbsp;&nbsp;&nbsp; glPushMatrix();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(330.0, 1.,0.,0.);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef (0.5, 0.5, 0.5);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginSurface(theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsSurface(theNurb,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8, knots,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8, knots,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 * 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ctlpoints[0][0][0],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, 4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_MAP2_VERTEX_3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndSurface(theNurb);

&nbsp;&nbsp;&nbsp; glPopMatrix();
&nbsp;&nbsp;&nbsp; glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
&nbsp;&nbsp;&nbsp; glViewport(0, 0, w, h);
&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
&nbsp;&nbsp;&nbsp; gluPerspective (45.0, (GLdouble)w/(GLdouble)h, 3.0, 8.0);

&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
&nbsp;&nbsp;&nbsp; glLoadIdentity();
&nbsp;&nbsp;&nbsp; glTranslatef (0.0, 0.0, -5.0);
}


int main(int argc, char** argv)
{
&nbsp;&nbsp;&nbsp; auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
&nbsp;&nbsp;&nbsp; auxInitPosition (0, 0, 500, 500);
&nbsp;&nbsp;&nbsp; auxInitWindow (argv[0]);
&nbsp;&nbsp;&nbsp; myinit();
&nbsp;&nbsp;&nbsp; auxReshapeFunc (myReshape);
&nbsp;&nbsp;&nbsp; auxMainLoop(display);
}</PRE>
As shown in Example 11-5 , <B>gluNewNurbsRenderer()</B> returns a new NURBS
object, whose type is a pointer to a GLUnurbsObj structure. The <B>gluBeginSurface()</B>
and <B>gluEndSurface()</B> pair bracket the rendering routine, saving and
restoring the evaluator state. These three routines are summarized in Appendix
C . The more complex routines, <B>gluNurbsProperty()</B> and <B>gluNurbsSurface()</B>,
are discussed in this section. void <B>gluNurbsProperty</B>(GLUnurbsObj
*<B>nobj</B>, GLenum <B>property</B>, GLfloat <B>value</B>);
<P>Controls attributes of a NURBS object, <B>nobj</B>. The <B>property</B>
argument specifies the property and can be GLU_SAMPLING_TOLERANCE, GLU_DISPLAY_MODE,
GLU_CULLING, or GLU_AUTO_LOAD_MATRIX. The <B>value</B> argument indicates
what the property should be. Since a NURBS object is rendered as primitives,
it's sampled at different values of its parameter(s) (<B>u</B> and <B>v</B>)
and broken down into small line segments or polygons for rendering. GLU_SAMPLING_TOLERANCE
controls how often the NURBS object is sampled. The default value of 50.0
makes the largest sampled line segment or polygon edge 50.0 pixels long.
<P>The default value for GLU_DISPLAY_MODE is GLU_FILL, which causes the
surface to be rendered as polygons. If GLU_OUTLINE_POLYGON is used for
the display-mode property, the outlines of polygons are rendered. Finally,
GLU_OUTLINE_PATCH renders the outlines of patches and trimming curves (see
the next section on trimming).
<P>GLU_CULLING can speed up performance by not performing tessellation
if the NURBS object falls completely outside the viewing volume; set this
property to GL_TRUE to enable culling (the default is GL_FALSE). The GLU_AUTO_LOAD_MATRIX
property determines whether the projection matrix, modelview matrix, and
viewport are downloaded from the OpenGL server (GL_TRUE, the default),
or whether the application must supply these matrices with <B>gluLoadSamplingMatrices()</B>
(GL_FALSE).
<P>void <B>gluNurbsSurface</B> (GLUnurbsObj *<B>nobj</B>, GLint <B>uknot_count</B>,
GLfloat *<B>uknot</B>, GLint <B>vknot_count</B>, GLfloat *<B>vknot</B>,
GLint <B>u_stride</B>, GLint <B>v_stride</B>, GLfloat *<B>ctlarray</B>,
GLint <B>uorder</B>, GLint <B>vorder</B>, GLenum <B>type</B>);
<P>Describes the vertices (or surface normals or texture coordinates) of
a NURBS surface, <B>nobj</B>. Several of the values must be specified for
both <I>u</I> and <I>v</I> parametric directions, such as the knot sequences
(<B>uknot</B> and <B>vknot</B>), knot counts (<B>uknot_count</B> and <B>vknot_count</B>),
and order of the polynomial (<B>uorder</B> and <B>vorder</B>) for the NURBS
surface. Note that the number of control points isn't specified. Instead,
it's derived by determining the number of control points along each parameter
as the number of knots minus the order. Then, the number of control points
for the surface is equal to the number of control points in each parametric
direction, multiplied by one another. The <B>ctlarray</B> argument points
to an array of control points.
<P>The last parameter, <B>type</B>, is one of the two-dimensional evaluator
types. Commonly, you might use GL_MAP2_VERTEX_3 for nonrational or GL_MAP2_VERTEX_4
for rational control points, respectively. You might also use other types,
such as GL_MAP2_TEXTURE_COORD_* or GL_MAP2_NORMAL to calculate and assign
texture coordinates or surface normals.
<P>The <B>u_stride</B> and <B>v_stride</B> arguments represent the number
of floating-point values between control points in each parametric direction.
The evaluator type, as well as its order, affects the <B>u_stride</B> and
<B>v_stride</B> values. In Example 11-5 , <B>u_stride</B> is 12 (4 * 3)
because there are three coordinates for each vertex (set by GL_MAP2_VERTEX_3)
and four control points in the parametric <B>v</B> direction; <B>v_stride</B>
is 3 because each vertex had three coordinates, and <B>v</B> control points
are adjacent to one another.
<P>Drawing a NURBS curve is similar to drawing a surface, except that all
calculations are done with one parameter, <B>u</B>, rather than two. Also,
for curves, <B>gluBeginCurve()</B> and <B>gluEndCurve()</B> are the bracketing
routines. void <B>gluNurbsCurve</B> (GLUnurbsObj *<B>nobj</B>, GLint <B>uknot_count</B>,
GLfloat *<B>uknot</B>, GLint <B>u_stride</B>, GLfloat *<B>ctlarray</B>,
GLint <B>uorder</B>, GLenum <B>type</B>);
<P>Defines a NURBS curve for the object <B>nobj</B>. The arguments have
the same meaning as those for <B>gluNurbsSurface()</B>. Note that this
routine requires only one knot sequence, and one declaration of the order
of the NURBS object. If this curve is defined within a <B>gluBeginCurve()/gluEndCurve()</B>
pair, then the type can be any of the valid one-dimensional evaluator types
(such as GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4).
<P>
<HR>
<H3>
Trimming</H3>
To create a trimmed NURBS surface with OpenGL, start as if you were creating
an untrimmed surface. After calling <B>gluBeginSurface()</B> and <B>gluNurbsSurface()</B>
but before calling <B>gluEndSurface()</B>, start a trim by calling <B>gluBeginTrim()</B>.
You can create two kinds of trimming curves, a piecewise linear curve with
<B>gluPwlCurve()</B> or a NURBS curve with <B>gluNurbsCurve()</B>. A piecewise
linear curve doesn't look like what's conventionally called a curve, because
it's a series of straight lines. A NURBS curve for trimming must lie within
the unit square of parametric (<I>u</I>,<I> v</I>) space. The type for
a NURBS trimming curve is usually GLU_MAP1_TRIM2. Less often, the type
is GLU_MAP1_TRIM3, where the curve is described in a two-dimensional homogeneous
space (<I>u', v', w</I>') by (<I>u, v</I>) = (<I>u'/w</I>', <I>v'/w</I>').
void <B>gluPwlCurve</B> (GLUnurbsObj *<B>nobj</B>, GLint <B>count</B>,
GLfloat *<B>array</B>, GLint <B>stride</B>, GLenum <B>type</B>);
<P>Describes a piecewise linear trimming curve for the NURBS object <B>nobj</B>.
There are <B>count</B> points on the curve, and they're given by <B>array</B>.
The <B>type</B> can be either GLU_MAP1_TRIM_2 (the most common) or GLU_MAP1_TRIM_3
((<I>u, v, w</I>) homogeneous parameter space). The type affects whether
<B>stride</B>, the number of floating-point values to the next vertex,
is 2 or 3.
<P>You need to consider the orientation of trimming curves - that is, whether
they're counterclockwise or clockwise - to make sure you include the desired
part of the surface. If you imagine walking along a curve, everything to
the left is included and everything to the right is trimmed away. For example,
if your trim consists of a single counterclockwise loop, everything inside
the loop is included. If the trim consists of two nonintersecting counterclockwise
loops with nonintersecting interiors, everything inside either of them
is included. If it consists of a counterclockwise loop with two clockwise
loops inside it, the trimming region has two holes in it. The outermost
trimming curve must be counterclockwise. Often, you run a trimming curve
around the entire unit square to include everything within it, which is
what you get by default by not specifying any trimming curves.
<P>Trimming curves must be closed and nonintersecting. You can combine
trimming curves, so long as the endpoints of the trimming curves meet to
form a closed curve. You can nest curves, creating islands that float in
space. Be sure to get the curve orientations right. For example, an error
results if you specify a trimming region with two counterclockwise curves,
one enclosed within another: The region between the curves is to the left
of one and to the right of the other, so it must be both included and excluded,
which is impossible. Figure 11-5 illustrates a few valid possibilities.
<P><IMG SRC="figures/fig11-5.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-5 : </B>Parametric Trimming Curves
<BR>&nbsp;
<BR>&nbsp;
<P>Figure 11-6 shows the same small hill as in Figure 11-4 , this time
with a trimming curve that's a combination of a piecewise linear curve
and a NURBS curve. The program that creates this figure is similar to that
shown in Example 11-5 ; the differences are in the routines shown in Example
11-6 .
<P><IMG SRC="figures/trim.both.gif" ALT="[IMAGE]" NOSAVE >
<P><B>Figure 11-6 : </B>A Trimmed NURBS Surface
<BR>&nbsp;
<BR>&nbsp;
<P><B>Example 11-6 : </B>Trimming a NURBS Surface: trim.c
<PRE>void myinit(void)
{
&nbsp;&nbsp;&nbsp; GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_specular[] = { 0.9, 0.9, 0.9, 1.0 };
&nbsp;&nbsp;&nbsp; GLfloat mat_shininess[] = { 128.0 };

&nbsp;&nbsp;&nbsp; glClearColor (0.0, 0.0, 0.0, 1.0);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);
&nbsp;&nbsp;&nbsp; glDepthFunc(GL_LEQUAL);
&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp; glEnable(GL_AUTO_NORMAL);
&nbsp;&nbsp;&nbsp; glEnable(GL_NORMALIZE);

&nbsp;&nbsp;&nbsp; init_surface();

&nbsp;&nbsp;&nbsp; theNurb = gluNewNurbsRenderer();
&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 50.0);
&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
&nbsp;&nbsp;&nbsp; GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
&nbsp;&nbsp;&nbsp; GLfloat edgePt[5][2] = /* counter clockwise */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0},&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0, 0.0}};
&nbsp;&nbsp;&nbsp; GLfloat curvePt[4][2] = /* clockwise */&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75}, {0.75, 0.5}};
&nbsp;&nbsp;&nbsp; GLfloat curveKnots[8] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
&nbsp;&nbsp;&nbsp; GLfloat pwlPt[4][2] = /* clockwise */&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};

&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&nbsp;&nbsp;&nbsp; glPushMatrix();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(330.0, 1.,0.,0.);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef (0.5, 0.5, 0.5);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginSurface(theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsSurface(theNurb,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8, knots,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8, knots,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 * 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ctlpoints[0][0][0],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, 4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_MAP2_VERTEX_3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginTrim (theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluPwlCurve(theNurb, 5, &amp;edgePt[0][0], 2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLU_MAP1_TRIM_2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndTrim (theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginTrim (theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsCurve(theNurb, 8, curveKnots, 2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;curvePt[0][0], 4, GLU_MAP1_TRIM_2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluPwlCurve (theNurb, 3, &amp;pwlPt[0][0], 2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLU_MAP1_TRIM_2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndTrim (theNurb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndSurface(theNurb);

&nbsp;&nbsp;&nbsp; glPopMatrix();
&nbsp;&nbsp;&nbsp; glFlush();
}</PRE>
In Example 11-6 , <B>gluBeginTrim()</B> and <B>gluEndTrim()</B> bracket
each trimming curve. The first trim, with vertices defined by the array
<B>edgePt[][]</B>, goes counterclockwise around the entire unit square
of parametric space. This ensures that everything is drawn, provided it
isn't removed by a clockwise trimming curve inside of it. The second trim
is a combination of a NURBS trimming curve and a piecewise linear trimming
curve. The NURBS curve ends at the points (0.9, 0.5) and (0.1, 0.5), where
it is met by the piecewise linear curve, forming a closed clockwise curve.
<P>
<HR><A HREF="chapter10.html">[Previous chapter]</A> <A HREF="chapter12.html">[Next
chapter]
<HR></A>See the <A HREF="about.html">About</A> page for copyright, authoring
and distribution information.
</BODY>
</HTML>
